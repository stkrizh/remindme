// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: reminder.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"
)

const countReminders = `-- name: CountReminders :one
SELECT COUNT(id) FROM reminder WHERE 
    ($1::boolean OR user_id = $2::bigint)
    AND ($3::boolean OR sent_at >= $4::timestamp)
    AND ($5::boolean OR status = ANY($6::text[]))
`

type CountRemindersParams struct {
	AnyUserID    bool
	UserIDEquals int64
	AnySentAt    bool
	SentAfter    time.Time
	AnyStatus    bool
	StatusIn     []string
}

func (q *Queries) CountReminders(ctx context.Context, arg CountRemindersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countReminders,
		arg.AnyUserID,
		arg.UserIDEquals,
		arg.AnySentAt,
		arg.SentAfter,
		arg.AnyStatus,
		arg.StatusIn,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createReminder = `-- name: CreateReminder :one
INSERT INTO reminder (user_id, created_at, scheduled_at, sent_at, canceled_at, at, every, status)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, user_id, created_at, at, status, every, scheduled_at, sent_at, canceled_at
`

type CreateReminderParams struct {
	UserID      int64
	CreatedAt   time.Time
	ScheduledAt sql.NullTime
	SentAt      sql.NullTime
	CanceledAt  sql.NullTime
	At          time.Time
	Every       sql.NullString
	Status      string
}

func (q *Queries) CreateReminder(ctx context.Context, arg CreateReminderParams) (Reminder, error) {
	row := q.db.QueryRow(ctx, createReminder,
		arg.UserID,
		arg.CreatedAt,
		arg.ScheduledAt,
		arg.SentAt,
		arg.CanceledAt,
		arg.At,
		arg.Every,
		arg.Status,
	)
	var i Reminder
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.At,
		&i.Status,
		&i.Every,
		&i.ScheduledAt,
		&i.SentAt,
		&i.CanceledAt,
	)
	return i, err
}

type CreateReminderChannelsParams struct {
	ReminderID int64
	ChannelID  int64
}

const readReminders = `-- name: ReadReminders :many
SELECT id, user_id, created_at, at, status, every, scheduled_at, sent_at, canceled_at FROM reminder WHERE 
    ($1::boolean OR user_id = $2::bigint)
    AND ($3::boolean OR sent_at >= $4::timestamp)
    AND ($5::boolean OR status = ANY($6::text[]))
ORDER BY 
    CASE WHEN $7::boolean THEN id ELSE null END,
    CASE WHEN $8::boolean THEN id ELSE null END DESC,
    CASE WHEN $9::boolean THEN at ELSE null END,
    CASE WHEN $10::boolean THEN at ELSE null END DESC,
    id ASC
`

type ReadRemindersParams struct {
	AnyUserID     bool
	UserIDEquals  int64
	AnySentAt     bool
	SentAfter     time.Time
	AnyStatus     bool
	StatusIn      []string
	OrderByIDAsc  bool
	OrderByIDDesc bool
	OrderByAtAsc  bool
	OrderByAtDesc bool
}

func (q *Queries) ReadReminders(ctx context.Context, arg ReadRemindersParams) ([]Reminder, error) {
	rows, err := q.db.Query(ctx, readReminders,
		arg.AnyUserID,
		arg.UserIDEquals,
		arg.AnySentAt,
		arg.SentAfter,
		arg.AnyStatus,
		arg.StatusIn,
		arg.OrderByIDAsc,
		arg.OrderByIDDesc,
		arg.OrderByAtAsc,
		arg.OrderByAtDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Reminder
	for rows.Next() {
		var i Reminder
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.At,
			&i.Status,
			&i.Every,
			&i.ScheduledAt,
			&i.SentAt,
			&i.CanceledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
