// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.16.0
// source: channel.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const activateChannel = `-- name: ActivateChannel :one
UPDATE channel 
SET verified_at = $3::timestamp, verification_token = null
WHERE id = $1 AND user_id = $2 AND verification_token = $4::text
RETURNING id, user_id, created_at, type, settings, verification_token, verified_at
`

type ActivateChannelParams struct {
	ID                int64
	UserID            int64
	VerifiedAt        time.Time
	VerificationToken string
}

func (q *Queries) ActivateChannel(ctx context.Context, arg ActivateChannelParams) (Channel, error) {
	row := q.db.QueryRow(ctx, activateChannel,
		arg.ID,
		arg.UserID,
		arg.VerifiedAt,
		arg.VerificationToken,
	)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.Type,
		&i.Settings,
		&i.VerificationToken,
		&i.VerifiedAt,
	)
	return i, err
}

const countChannels = `-- name: CountChannels :one
SELECT COUNT(id) FROM channel WHERE
    ($1::boolean OR user_id = $2::bigint)
    AND ($3::boolean OR type = $4::text)
`

type CountChannelsParams struct {
	AllUserIds   bool
	UserIDEquals int64
	AllTypes     bool
	TypeEquals   string
}

func (q *Queries) CountChannels(ctx context.Context, arg CountChannelsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countChannels,
		arg.AllUserIds,
		arg.UserIDEquals,
		arg.AllTypes,
		arg.TypeEquals,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createChannel = `-- name: CreateChannel :one
INSERT INTO channel (user_id, created_at, type, settings, verification_token, verified_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, created_at, type, settings, verification_token, verified_at
`

type CreateChannelParams struct {
	UserID            int64
	CreatedAt         time.Time
	Type              string
	Settings          pgtype.JSONB
	VerificationToken sql.NullString
	VerifiedAt        sql.NullTime
}

func (q *Queries) CreateChannel(ctx context.Context, arg CreateChannelParams) (Channel, error) {
	row := q.db.QueryRow(ctx, createChannel,
		arg.UserID,
		arg.CreatedAt,
		arg.Type,
		arg.Settings,
		arg.VerificationToken,
		arg.VerifiedAt,
	)
	var i Channel
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.Type,
		&i.Settings,
		&i.VerificationToken,
		&i.VerifiedAt,
	)
	return i, err
}

const readChanels = `-- name: ReadChanels :many
SELECT id, user_id, created_at, type, settings, verification_token, verified_at FROM channel WHERE 
    ($1::boolean OR user_id = $2::bigint)
    AND ($3::boolean OR type = $4::text)
ORDER BY id
`

type ReadChanelsParams struct {
	AllUserIds   bool
	UserIDEquals int64
	AllTypes     bool
	TypeEquals   string
}

func (q *Queries) ReadChanels(ctx context.Context, arg ReadChanelsParams) ([]Channel, error) {
	rows, err := q.db.Query(ctx, readChanels,
		arg.AllUserIds,
		arg.UserIDEquals,
		arg.AllTypes,
		arg.TypeEquals,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Channel
	for rows.Next() {
		var i Channel
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreatedAt,
			&i.Type,
			&i.Settings,
			&i.VerificationToken,
			&i.VerifiedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
